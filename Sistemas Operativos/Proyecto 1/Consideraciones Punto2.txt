para 2.3:

	Habiendo leido el libro, la cosa es así, todo Thread de usuario debe conectarse a un Thread de Kernel para poder ser planificado por el CPU, si existen varios threads de usuario, estos compiten entre si por el/los Thread/s de Kernel para luego ser planificados por el CPU. Si un proceso solo tiene Threads de kernel, esos Threads compiten por el CPU.
	Por ende, que un Proceso tenga múltiples Threads asociados implica que su Burst de CPU es la suma del trabajo hecho por los Threads de forma separada, por ende, si estoy usando un SJF, la planificación dependerá de la suma de los trabajos de los Threads, si un Proceso P1 tiene un Thread de Kernel que tiene un burst de 8ms y un Proceso P2 tiene 2 Threads de Kernel que tienen un burst de 3ms Cada uno, por SJF, el Proceso P2 tiene prioridad sobre P1 ya que el tiempo que pasa P2 laburando es menor al de P1 (6 ms contra 8ms) (acá asumo que ambos Procesos entran al mismo tiempo)
	Para Planificación Round-Robin, el Quantum me da cuanto tiempo espera el CPU hasta que hace un cambio de contexto, los procesos se almacenan en una Cola Circular con mecánica FIFO, entonces, si un Proceso P1 entra al CPU, su tiempo requerido es de 24ms pero el Quanto de TIempo es 4ms, P1 solo trabajará por 4ms y luego será sacado del CPU para dar lugar a otro Proceso, volviendo al final de la Cola de Espera.